/*
 * ucd_clkup_v1_api
 * Swagger documentation for UCD Customer Lookup Service API
 *
 * The version of the OpenAPI document: 1.0.2
 * Contact: UCDWSDevTeam@westernunion.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.wu.brwallet.customer.profile.model.common.ucd.customerlookup;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;

import java.util.HashSet;
import java.util.Map.Entry;
import java.util.Set;

/**
 * This is the request model for MultiParanNonKeyLookup service. This is to search for a customer by supplying multiple non-key elements and receive the UCD profile of the customer found.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-03-17T20:02:06.369160100+05:30[Asia/Calcutta]")
public class MultiParamNonKeyLookupRequest {
  public static final String SERIALIZED_NAME_HEADER = "header";
  @SerializedName(SERIALIZED_NAME_HEADER)
  private Header header;

  public static final String SERIALIZED_NAME_LOOKUP_TYPE = "lookupType";
  @SerializedName(SERIALIZED_NAME_LOOKUP_TYPE)
  private String lookupType;

  public static final String SERIALIZED_NAME_MATCHING_TYPE = "matchingType";
  @SerializedName(SERIALIZED_NAME_MATCHING_TYPE)
  private String matchingType;

  public static final String SERIALIZED_NAME_LOOKUP_KEY = "lookupKey";
  @SerializedName(SERIALIZED_NAME_LOOKUP_KEY)
  private MultiParamLookupKey lookupKey;

  public static final String SERIALIZED_NAME_RESPONSE_TYPE = "responseType";
  @SerializedName(SERIALIZED_NAME_RESPONSE_TYPE)
  private String responseType;

  public static final String SERIALIZED_NAME_START_INDEX = "startIndex";
  @SerializedName(SERIALIZED_NAME_START_INDEX)
  private Integer startIndex;

  public static final String SERIALIZED_NAME_RETURN_SIZE = "returnSize";
  @SerializedName(SERIALIZED_NAME_RETURN_SIZE)
  private Integer returnSize;

  /**
   * This flag would indicate to filter out the Active / Inactive customers.   * If this flag value is N or not sent, then by will look in both Active &amp; Inactive Customers.   * If the flag value is Y, then will look in Active Customers. 
   */
  @JsonAdapter(CustomerActiveFlagEnum.Adapter.class)
  public enum CustomerActiveFlagEnum {
    Y("Y"),
    
    N("N");

    private String value;

    CustomerActiveFlagEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static CustomerActiveFlagEnum fromValue(String value) {
      for (CustomerActiveFlagEnum b : CustomerActiveFlagEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<CustomerActiveFlagEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CustomerActiveFlagEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CustomerActiveFlagEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return CustomerActiveFlagEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_CUSTOMER_ACTIVE_FLAG = "customerActiveFlag";
  @SerializedName(SERIALIZED_NAME_CUSTOMER_ACTIVE_FLAG)
  private CustomerActiveFlagEnum customerActiveFlag = CustomerActiveFlagEnum.N;

  /**
   * This flag would indicate to filter out the MyWU / Non-MyWU customers.   * If this flag value is N or not sent, then by will look in My_WU customers.   * If the flag value is Y, then will look in both My_WU &amp; Non_My_WU customers. 
   */
  @JsonAdapter(SendNonWuAlsoFlagEnum.Adapter.class)
  public enum SendNonWuAlsoFlagEnum {
    Y("Y"),
    
    N("N");

    private String value;

    SendNonWuAlsoFlagEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SendNonWuAlsoFlagEnum fromValue(String value) {
      for (SendNonWuAlsoFlagEnum b : SendNonWuAlsoFlagEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SendNonWuAlsoFlagEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SendNonWuAlsoFlagEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SendNonWuAlsoFlagEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SendNonWuAlsoFlagEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_SEND_NON_WU_ALSO_FLAG = "sendNonWuAlsoFlag";
  @SerializedName(SERIALIZED_NAME_SEND_NON_WU_ALSO_FLAG)
  private SendNonWuAlsoFlagEnum sendNonWuAlsoFlag = SendNonWuAlsoFlagEnum.Y;

  /**
   * This flag would indicate to filter out the partial customers.   * If this flag value is N or not sent, then by will look in Full customers.   * If the flag value is Y, then will look in Full + Partial customers. 
   */
  @JsonAdapter(SendPartialCustomerFlagEnum.Adapter.class)
  public enum SendPartialCustomerFlagEnum {
    Y("Y"),
    
    N("N");

    private String value;

    SendPartialCustomerFlagEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SendPartialCustomerFlagEnum fromValue(String value) {
      for (SendPartialCustomerFlagEnum b : SendPartialCustomerFlagEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SendPartialCustomerFlagEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SendPartialCustomerFlagEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SendPartialCustomerFlagEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SendPartialCustomerFlagEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_SEND_PARTIAL_CUSTOMER_FLAG = "sendPartialCustomerFlag";
  @SerializedName(SERIALIZED_NAME_SEND_PARTIAL_CUSTOMER_FLAG)
  private SendPartialCustomerFlagEnum sendPartialCustomerFlag = SendPartialCustomerFlagEnum.N;

  public static final String SERIALIZED_NAME_CUSTOMER_KYC_DETAILS_ACTIVE_FLAG = "customerKycDetailsActiveFlag";
  @SerializedName(SERIALIZED_NAME_CUSTOMER_KYC_DETAILS_ACTIVE_FLAG)
  private String customerKycDetailsActiveFlag;

  /**
   * This flag would indicate to filter out the Digital / Retail customers. For Name AND DOB lookup,    * If this flag value is N or not sent, then by default will look in Digital + Retail customers.   * If the flag value is Y, then will look in only Digital customers. 
   */
  @JsonAdapter(CheckOnlyForDigitalEnum.Adapter.class)
  public enum CheckOnlyForDigitalEnum {
    Y("Y"),
    
    N("N");

    private String value;

    CheckOnlyForDigitalEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static CheckOnlyForDigitalEnum fromValue(String value) {
      for (CheckOnlyForDigitalEnum b : CheckOnlyForDigitalEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<CheckOnlyForDigitalEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CheckOnlyForDigitalEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CheckOnlyForDigitalEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return CheckOnlyForDigitalEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_CHECK_ONLY_FOR_DIGITAL = "checkOnlyForDigital";
  @SerializedName(SERIALIZED_NAME_CHECK_ONLY_FOR_DIGITAL)
  private CheckOnlyForDigitalEnum checkOnlyForDigital = CheckOnlyForDigitalEnum.N;

  public static final String SERIALIZED_NAME_CHANNEL_TYPE = "channelType";
  @SerializedName(SERIALIZED_NAME_CHANNEL_TYPE)
  private Integer channelType;

  /**
   * This flag would indicate that the search should include Convenience or not.    * If this flag value is N or not sent, then by the search will be across Customers only.    * If the flag value is Y, then the search will be across both Convenience and Customers.  
   */
  @JsonAdapter(IncludeConvenienceFlagEnum.Adapter.class)
  public enum IncludeConvenienceFlagEnum {
    Y("Y"),
    
    N("N");

    private String value;

    IncludeConvenienceFlagEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static IncludeConvenienceFlagEnum fromValue(String value) {
      for (IncludeConvenienceFlagEnum b : IncludeConvenienceFlagEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<IncludeConvenienceFlagEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final IncludeConvenienceFlagEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public IncludeConvenienceFlagEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return IncludeConvenienceFlagEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_INCLUDE_CONVENIENCE_FLAG = "includeConvenienceFlag";
  @SerializedName(SERIALIZED_NAME_INCLUDE_CONVENIENCE_FLAG)
  private IncludeConvenienceFlagEnum includeConvenienceFlag = IncludeConvenienceFlagEnum.N;

  public static final String SERIALIZED_NAME_PLATFORM = "platform";
  @SerializedName(SERIALIZED_NAME_PLATFORM)
  private String platform = "W";

  /**
   * This flag would indicate to include customers of level codes - XXC, WU6 &amp; WU7 or not.   * If this flag is N or not sent, then by the search will not return customer(s) with level code - XXC, WU6 &amp; WU7.    * If this flag value is Y, then the search will return customer(s) irrespective of the level codes. 
   */
  @JsonAdapter(SendAllPfcEnum.Adapter.class)
  public enum SendAllPfcEnum {
    Y("Y"),
    
    N("N");

    private String value;

    SendAllPfcEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SendAllPfcEnum fromValue(String value) {
      for (SendAllPfcEnum b : SendAllPfcEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SendAllPfcEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SendAllPfcEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SendAllPfcEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SendAllPfcEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_SEND_ALL_PFC = "sendAllPfc";
  @SerializedName(SERIALIZED_NAME_SEND_ALL_PFC)
  private SendAllPfcEnum sendAllPfc = SendAllPfcEnum.N;

  /**
   * Flag which indicates to/not to convert the Special Characters to ASCII for Sender &amp; Receiver details (Name, Address, Address in UAB). For Loyalty, this flag will be defaulted to Y. * If not passed in the request, as is values will be returned in response by default. * If passed as N in the request, as is values will be returned in response. * If passed as Y in the request, the Special Characters will be converted to ASCII and will be returned in response. 
   */
  @JsonAdapter(EnableTransliterationFlagEnum.Adapter.class)
  public enum EnableTransliterationFlagEnum {
    Y("Y"),
    
    N("N");

    private String value;

    EnableTransliterationFlagEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static EnableTransliterationFlagEnum fromValue(String value) {
      for (EnableTransliterationFlagEnum b : EnableTransliterationFlagEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<EnableTransliterationFlagEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final EnableTransliterationFlagEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public EnableTransliterationFlagEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return EnableTransliterationFlagEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_ENABLE_TRANSLITERATION_FLAG = "enableTransliterationFlag";
  @SerializedName(SERIALIZED_NAME_ENABLE_TRANSLITERATION_FLAG)
  private EnableTransliterationFlagEnum enableTransliterationFlag = EnableTransliterationFlagEnum.N;

  /**
   * This flag would indicate to include all types of Funding Sources or not.    * If this flag value is N or not sent, then will return Funding Sources which are added by other than TMT.   * If the flag value is &#39;Y&#39;, then will return additional funding sources (like funding sources added by TMT), if any, along with funding sources added by other than TMT. 
   */
  @JsonAdapter(SendAllFundSrcEnum.Adapter.class)
  public enum SendAllFundSrcEnum {
    Y("Y"),
    
    N("N");

    private String value;

    SendAllFundSrcEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SendAllFundSrcEnum fromValue(String value) {
      for (SendAllFundSrcEnum b : SendAllFundSrcEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SendAllFundSrcEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SendAllFundSrcEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SendAllFundSrcEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SendAllFundSrcEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_SEND_ALL_FUND_SRC = "sendAllFundSrc";
  @SerializedName(SERIALIZED_NAME_SEND_ALL_FUND_SRC)
  private SendAllFundSrcEnum sendAllFundSrc = SendAllFundSrcEnum.N;

  /**
   * This flag would indicate to include all the PhoneVvStatus or not.   * PhoneVvStatus - N / L / M / P will be returned in response by default.    * PhoneVvStatus - Z / T / R / S / V / A / B / U / C / D will only be returned if this field is send as Y in the request.&#39; 
   */
  @JsonAdapter(SendAllPhoneVvStatusEnum.Adapter.class)
  public enum SendAllPhoneVvStatusEnum {
    Y("Y"),
    
    N("N");

    private String value;

    SendAllPhoneVvStatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SendAllPhoneVvStatusEnum fromValue(String value) {
      for (SendAllPhoneVvStatusEnum b : SendAllPhoneVvStatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SendAllPhoneVvStatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SendAllPhoneVvStatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SendAllPhoneVvStatusEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SendAllPhoneVvStatusEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_SEND_ALL_PHONE_VV_STATUS = "sendAllPhoneVvStatus";
  @SerializedName(SERIALIZED_NAME_SEND_ALL_PHONE_VV_STATUS)
  private SendAllPhoneVvStatusEnum sendAllPhoneVvStatus = SendAllPhoneVvStatusEnum.N;

  public static final String SERIALIZED_NAME_NO_OF_YEARS_IN_SEARCH = "noOfYearsInSearch";
  @SerializedName(SERIALIZED_NAME_NO_OF_YEARS_IN_SEARCH)
  private Integer noOfYearsInSearch;

  /**
   * This flag would indicate to include complete customer details or not (if a single match is found).   * If this flag value is N or not sent, then it will return limited details of the Customer.   * If the flag value is &#39;Y&#39;, then web service will return all the details of the Customer if a single match is found else will return limited details of the Customers. 
   */
  @JsonAdapter(SendAllCustomerDetailsEnum.Adapter.class)
  public enum SendAllCustomerDetailsEnum {
    Y("Y"),
    
    N("N");

    private String value;

    SendAllCustomerDetailsEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SendAllCustomerDetailsEnum fromValue(String value) {
      for (SendAllCustomerDetailsEnum b : SendAllCustomerDetailsEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SendAllCustomerDetailsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SendAllCustomerDetailsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SendAllCustomerDetailsEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SendAllCustomerDetailsEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_SEND_ALL_CUSTOMER_DETAILS = "sendAllCustomerDetails";
  @SerializedName(SERIALIZED_NAME_SEND_ALL_CUSTOMER_DETAILS)
  private SendAllCustomerDetailsEnum sendAllCustomerDetails = SendAllCustomerDetailsEnum.N;

  /**
   * *Note: This field is deprecated. Please use enableCrossChannelFlag field instead.* * Flag which indicates to search across All profiles or only Primary UMN profile.   * If not passed in the request, all the profiles will be returned in response by default.   * If passed as N in the request, all the profiles will be returned in response.   * If passed as Y in the request, only the Primary UMN profile will be returned in response. 
   */
  @JsonAdapter(SendPrimaryProfileFlagEnum.Adapter.class)
  public enum SendPrimaryProfileFlagEnum {
    Y("Y"),
    
    N("N");

    private String value;

    SendPrimaryProfileFlagEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SendPrimaryProfileFlagEnum fromValue(String value) {
      for (SendPrimaryProfileFlagEnum b : SendPrimaryProfileFlagEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SendPrimaryProfileFlagEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SendPrimaryProfileFlagEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SendPrimaryProfileFlagEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SendPrimaryProfileFlagEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_SEND_PRIMARY_PROFILE_FLAG = "sendPrimaryProfileFlag";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_SEND_PRIMARY_PROFILE_FLAG)
  private SendPrimaryProfileFlagEnum sendPrimaryProfileFlag = SendPrimaryProfileFlagEnum.N;

  /**
   * Flag which indicates to search across All profiles or only Primary UMN profile. * If not passed in the request, all the profiles will be returned in response by default. * If passed as N in the request, all the profiles will be returned in response. * If passed as Y in the request, then   * Only the Primary UMN profile will be returned in response.   * platform will get defaulted to A   * noOfYearsInSearch passed in the request will get ignored 
   */
  @JsonAdapter(EnableCrossChannelFlagEnum.Adapter.class)
  public enum EnableCrossChannelFlagEnum {
    Y("Y"),
    
    N("N");

    private String value;

    EnableCrossChannelFlagEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static EnableCrossChannelFlagEnum fromValue(String value) {
      for (EnableCrossChannelFlagEnum b : EnableCrossChannelFlagEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<EnableCrossChannelFlagEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final EnableCrossChannelFlagEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public EnableCrossChannelFlagEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return EnableCrossChannelFlagEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_ENABLE_CROSS_CHANNEL_FLAG = "enableCrossChannelFlag";
  @SerializedName(SERIALIZED_NAME_ENABLE_CROSS_CHANNEL_FLAG)
  private EnableCrossChannelFlagEnum enableCrossChannelFlag = EnableCrossChannelFlagEnum.N;

  /**
   * This flag would indicate to include consolidated funding sources from both primary &amp; secondary profiles or not.   * If this flag value is &#39;N&#39; or not sent, then it will return funding sources from primary profile only.   * If the flag value is &#39;Y&#39;, then web service will return consolidated funding sources from both primary &amp; scondary profiles. 
   */
  @JsonAdapter(SendConsolidatedFundingSourcesEnum.Adapter.class)
  public enum SendConsolidatedFundingSourcesEnum {
    Y("Y"),
    
    N("N");

    private String value;

    SendConsolidatedFundingSourcesEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SendConsolidatedFundingSourcesEnum fromValue(String value) {
      for (SendConsolidatedFundingSourcesEnum b : SendConsolidatedFundingSourcesEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SendConsolidatedFundingSourcesEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SendConsolidatedFundingSourcesEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SendConsolidatedFundingSourcesEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SendConsolidatedFundingSourcesEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_SEND_CONSOLIDATED_FUNDING_SOURCES = "sendConsolidatedFundingSources";
  @SerializedName(SERIALIZED_NAME_SEND_CONSOLIDATED_FUNDING_SOURCES)
  private SendConsolidatedFundingSourcesEnum sendConsolidatedFundingSources = SendConsolidatedFundingSourcesEnum.N;

  /**
   * This flag would indicate to include consolidated receviers from both primary &amp; secondary profiles or not.   * If this flag value is &#39;N&#39; or not sent, then it will return receviers from primary profile only.   * If the flag value is &#39;Y&#39;, then web service will return consolidated receivers from both primary &amp; scondary profiles. 
   */
  @JsonAdapter(SendConsolidatedReceiversEnum.Adapter.class)
  public enum SendConsolidatedReceiversEnum {
    Y("Y"),
    
    N("N");

    private String value;

    SendConsolidatedReceiversEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SendConsolidatedReceiversEnum fromValue(String value) {
      for (SendConsolidatedReceiversEnum b : SendConsolidatedReceiversEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SendConsolidatedReceiversEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SendConsolidatedReceiversEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SendConsolidatedReceiversEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SendConsolidatedReceiversEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_SEND_CONSOLIDATED_RECEIVERS = "sendConsolidatedReceivers";
  @SerializedName(SERIALIZED_NAME_SEND_CONSOLIDATED_RECEIVERS)
  private SendConsolidatedReceiversEnum sendConsolidatedReceivers = SendConsolidatedReceiversEnum.N;

  public static final String SERIALIZED_NAME_PHONE_AND_DOB_FLAG = "phoneAndDobFlag";
  @SerializedName(SERIALIZED_NAME_PHONE_AND_DOB_FLAG)
  private String phoneAndDobFlag = "1";

  public static final String SERIALIZED_NAME_SORTING_ORDER = "sortingOrder";
  @SerializedName(SERIALIZED_NAME_SORTING_ORDER)
  private String sortingOrder = "1";

  public static final String SERIALIZED_NAME_SEND_CUST_HAVING_ACCOUNT_FLAG = "sendCustHavingAccountFlag";
  @SerializedName(SERIALIZED_NAME_SEND_CUST_HAVING_ACCOUNT_FLAG)
  private List<Integer> sendCustHavingAccountFlag;

  public static final String SERIALIZED_NAME_COUNTRY_CODE_ISO2 = "countryCodeIso2";
  @SerializedName(SERIALIZED_NAME_COUNTRY_CODE_ISO2)
  private String countryCodeIso2;

  public static final String SERIALIZED_NAME_COUNTRY_CODE_ISO3 = "countryCodeIso3";
  @SerializedName(SERIALIZED_NAME_COUNTRY_CODE_ISO3)
  private String countryCodeIso3;

  public static final String SERIALIZED_NAME_REQUEST_INITIATED_BY = "requestInitiatedBy";
  @SerializedName(SERIALIZED_NAME_REQUEST_INITIATED_BY)
  private String requestInitiatedBy;

  public MultiParamNonKeyLookupRequest() {
  }

  public MultiParamNonKeyLookupRequest header(Header header) {
    
    this.header = header;
    return this;
  }

   /**
   * Get header
   * @return header
  **/
  @javax.annotation.Nonnull
  public Header getHeader() {
    return header;
  }


  public void setHeader(Header header) {
    this.header = header;
  }


  public MultiParamNonKeyLookupRequest lookupType(String lookupType) {
    
    this.lookupType = lookupType;
    return this;
  }

   /**
   * Indicates elements to be considered for lookup Indicates AND/OR condition for the lookup elements Currently this operation supports below combination -   1. Name AND PhoneHash       * Value to be passed in this element for Name AND PhoneHash combination is NPM.       * When LookupType &#x3D; NPM, Name and ISDCodePlusPhoneNumber elements are mandatory.   2. ID Number       * Value to be passed in this element for ID Number is KYCIDNUM.       * When LookupType &#x3D; KYCIDNUM, IDNumber element is mandatory.   3. Name AND DOB       * Value to be passed in this element for Name AND DOB combination is ND.       * When LookupType &#x3D; ND, Name and DOB are mandatory.   4. PhoneHash AND DOB       * Value to be passed in this element for PhoneHash AND DOB combination is PHD.       * When LookupType &#x3D; PHD, ISDCodePlusPhoneNumber is mandatory and DOB is optional.   5. Id Type AND Id Number AND CountryCode       * Value to be passed in this element for IdType AND IdNumber AND CountryCode combination is IDIDNCC.       * When LookupType &#x3D; IDIDNCC, IdType and IdNumber and CountryCodeIso2/CountryCodeIso3 are mandatory. 
   * @return lookupType
  **/
  @javax.annotation.Nonnull
  public String getLookupType() {
    return lookupType;
  }


  public void setLookupType(String lookupType) {
    this.lookupType = lookupType;
  }


  public MultiParamNonKeyLookupRequest matchingType(String matchingType) {
    
    this.matchingType = matchingType;
    return this;
  }

   /**
   * Indicates whether partial match or exact match for each element. Currently this operation supports below combination-   1. Name-PartialMatch PhoneHash-ExactMatch.       * Value to be passed for this combination is NpartialPHexact.       * This value is valid for LookupType- NPH   2. IDNumber-ExactMatch       * Value to be passed for this combination is KYCIDNUMEXACT.       * This value is valid for LookupType- KYCIDNUM   3. Name-PartialMatch DOB-ExactMatch.       * Value to be passed for this combination is NpartialDexact.       * This value is valid for LookupType- ND.   4. PhoneHash-ExactMatch DOB-ExactMatch       * Value to be passed for this combination is PHexactDexact       * This value is valid for LookupType- PHD   5. IdType-ExactMatch IDNumber-ExactMatch CountryCode-ExactMatch       * Value to be passed for this combination is IDexactIDNexactCCexact       * This value is valid for LookupType- IDIDNCC 
   * @return matchingType
  **/
  @javax.annotation.Nonnull
  public String getMatchingType() {
    return matchingType;
  }


  public void setMatchingType(String matchingType) {
    this.matchingType = matchingType;
  }


  public MultiParamNonKeyLookupRequest lookupKey(MultiParamLookupKey lookupKey) {
    
    this.lookupKey = lookupKey;
    return this;
  }

   /**
   * Get lookupKey
   * @return lookupKey
  **/
  @javax.annotation.Nonnull
  public MultiParamLookupKey getLookupKey() {
    return lookupKey;
  }


  public void setLookupKey(MultiParamLookupKey lookupKey) {
    this.lookupKey = lookupKey;
  }


  public MultiParamNonKeyLookupRequest responseType(String responseType) {
    
    this.responseType = responseType;
    return this;
  }

   /**
   * Indicates the set of customer profile elements to be returned in response. Currently this operations supports only below values   * S - Summary   * D - Detailed   * C - Complete 
   * @return responseType
  **/
  @javax.annotation.Nonnull
  public String getResponseType() {
    return responseType;
  }


  public void setResponseType(String responseType) {
    this.responseType = responseType;
  }


  public MultiParamNonKeyLookupRequest startIndex(Integer startIndex) {
    
    this.startIndex = startIndex;
    return this;
  }

   /**
   * If StartIndex field is 0 or given value for this element is not available then web service will return customer&#39;s from Customer Sequence No #1 to number of receivers specified in returnSize field. 
   * @return startIndex
  **/
  @javax.annotation.Nonnull
  public Integer getStartIndex() {
    return startIndex;
  }


  public void setStartIndex(Integer startIndex) {
    this.startIndex = startIndex;
  }


  public MultiParamNonKeyLookupRequest returnSize(Integer returnSize) {
    
    this.returnSize = returnSize;
    return this;
  }

   /**
   * If StartIndex field is &#39;X&#39; (greater than 0) then UCD will return customer&#39;s from Customer Sequence No #&#39;X+1&#39; to number of Customer&#39;s specified in ReturnSize field. 
   * @return returnSize
  **/
  @javax.annotation.Nonnull
  public Integer getReturnSize() {
    return returnSize;
  }


  public void setReturnSize(Integer returnSize) {
    this.returnSize = returnSize;
  }


  public MultiParamNonKeyLookupRequest customerActiveFlag(CustomerActiveFlagEnum customerActiveFlag) {
    
    this.customerActiveFlag = customerActiveFlag;
    return this;
  }

   /**
   * This flag would indicate to filter out the Active / Inactive customers.   * If this flag value is N or not sent, then by will look in both Active &amp; Inactive Customers.   * If the flag value is Y, then will look in Active Customers. 
   * @return customerActiveFlag
  **/
  @javax.annotation.Nonnull
  public CustomerActiveFlagEnum getCustomerActiveFlag() {
    return customerActiveFlag;
  }


  public void setCustomerActiveFlag(CustomerActiveFlagEnum customerActiveFlag) {
    this.customerActiveFlag = customerActiveFlag;
  }


  public MultiParamNonKeyLookupRequest sendNonWuAlsoFlag(SendNonWuAlsoFlagEnum sendNonWuAlsoFlag) {
    
    this.sendNonWuAlsoFlag = sendNonWuAlsoFlag;
    return this;
  }

   /**
   * This flag would indicate to filter out the MyWU / Non-MyWU customers.   * If this flag value is N or not sent, then by will look in My_WU customers.   * If the flag value is Y, then will look in both My_WU &amp; Non_My_WU customers. 
   * @return sendNonWuAlsoFlag
  **/
  @javax.annotation.Nullable
  public SendNonWuAlsoFlagEnum getSendNonWuAlsoFlag() {
    return sendNonWuAlsoFlag;
  }


  public void setSendNonWuAlsoFlag(SendNonWuAlsoFlagEnum sendNonWuAlsoFlag) {
    this.sendNonWuAlsoFlag = sendNonWuAlsoFlag;
  }


  public MultiParamNonKeyLookupRequest sendPartialCustomerFlag(SendPartialCustomerFlagEnum sendPartialCustomerFlag) {
    
    this.sendPartialCustomerFlag = sendPartialCustomerFlag;
    return this;
  }

   /**
   * This flag would indicate to filter out the partial customers.   * If this flag value is N or not sent, then by will look in Full customers.   * If the flag value is Y, then will look in Full + Partial customers. 
   * @return sendPartialCustomerFlag
  **/
  @javax.annotation.Nullable
  public SendPartialCustomerFlagEnum getSendPartialCustomerFlag() {
    return sendPartialCustomerFlag;
  }


  public void setSendPartialCustomerFlag(SendPartialCustomerFlagEnum sendPartialCustomerFlag) {
    this.sendPartialCustomerFlag = sendPartialCustomerFlag;
  }


  public MultiParamNonKeyLookupRequest customerKycDetailsActiveFlag(String customerKycDetailsActiveFlag) {
    
    this.customerKycDetailsActiveFlag = customerKycDetailsActiveFlag;
    return this;
  }

   /**
   * ActiveRecords - Return records with Active Flag value as &#39;Y&#39; in DB AllRecords - Return all records irrespective of Active Flag value in DB
   * @return customerKycDetailsActiveFlag
  **/
  @javax.annotation.Nullable
  public String getCustomerKycDetailsActiveFlag() {
    return customerKycDetailsActiveFlag;
  }


  public void setCustomerKycDetailsActiveFlag(String customerKycDetailsActiveFlag) {
    this.customerKycDetailsActiveFlag = customerKycDetailsActiveFlag;
  }


  public MultiParamNonKeyLookupRequest checkOnlyForDigital(CheckOnlyForDigitalEnum checkOnlyForDigital) {
    
    this.checkOnlyForDigital = checkOnlyForDigital;
    return this;
  }

   /**
   * This flag would indicate to filter out the Digital / Retail customers. For Name AND DOB lookup,    * If this flag value is N or not sent, then by default will look in Digital + Retail customers.   * If the flag value is Y, then will look in only Digital customers. 
   * @return checkOnlyForDigital
  **/
  @javax.annotation.Nullable
  public CheckOnlyForDigitalEnum getCheckOnlyForDigital() {
    return checkOnlyForDigital;
  }


  public void setCheckOnlyForDigital(CheckOnlyForDigitalEnum checkOnlyForDigital) {
    this.checkOnlyForDigital = checkOnlyForDigital;
  }


  public MultiParamNonKeyLookupRequest channelType(Integer channelType) {
    
    this.channelType = channelType;
    return this;
  }

   /**
   * This flag would indicate to include channnel specific CustomerKYCDetails and CustomerVerification * If not passed in request, CustomerKYCDetails and CustomerVerification will be defaulted to Channel Type 1 * If passed in request, CustomerKYCDetails and CustomerVerification will be corresponding to the Channel Type passed 
   * @return channelType
  **/
  @javax.annotation.Nullable
  public Integer getChannelType() {
    return channelType;
  }


  public void setChannelType(Integer channelType) {
    this.channelType = channelType;
  }


  public MultiParamNonKeyLookupRequest includeConvenienceFlag(IncludeConvenienceFlagEnum includeConvenienceFlag) {
    
    this.includeConvenienceFlag = includeConvenienceFlag;
    return this;
  }

   /**
   * This flag would indicate that the search should include Convenience or not.    * If this flag value is N or not sent, then by the search will be across Customers only.    * If the flag value is Y, then the search will be across both Convenience and Customers.  
   * @return includeConvenienceFlag
  **/
  @javax.annotation.Nullable
  public IncludeConvenienceFlagEnum getIncludeConvenienceFlag() {
    return includeConvenienceFlag;
  }


  public void setIncludeConvenienceFlag(IncludeConvenienceFlagEnum includeConvenienceFlag) {
    this.includeConvenienceFlag = includeConvenienceFlag;
  }


  public MultiParamNonKeyLookupRequest platform(String platform) {
    
    this.platform = platform;
    return this;
  }

   /**
   * Added as part of OVI/VIGO changes, where this flag is responsible for filtering out the OVI/VIGO customer based on the flag passed in the request. For Phoenix, this flag will be defaulted to A. * If the flag value is \&quot;A\&quot;, lookup details irrespective of platform will be returned. * If the flag value is \&quot;O\&quot;, lookup details who are part of OVI platform will be returned. * If the flag value is \&quot;V\&quot;, lookup details who are part of VIGO platform will be returned. * The default value is \&quot;W\&quot; and lookup details who are WU customers needs to be returned, but not OVI/VIGO. 
   * @return platform
  **/
  @javax.annotation.Nullable
  public String getPlatform() {
    return platform;
  }


  public void setPlatform(String platform) {
    this.platform = platform;
  }


  public MultiParamNonKeyLookupRequest sendAllPfc(SendAllPfcEnum sendAllPfc) {
    
    this.sendAllPfc = sendAllPfc;
    return this;
  }

   /**
   * This flag would indicate to include customers of level codes - XXC, WU6 &amp; WU7 or not.   * If this flag is N or not sent, then by the search will not return customer(s) with level code - XXC, WU6 &amp; WU7.    * If this flag value is Y, then the search will return customer(s) irrespective of the level codes. 
   * @return sendAllPfc
  **/
  @javax.annotation.Nullable
  public SendAllPfcEnum getSendAllPfc() {
    return sendAllPfc;
  }


  public void setSendAllPfc(SendAllPfcEnum sendAllPfc) {
    this.sendAllPfc = sendAllPfc;
  }


  public MultiParamNonKeyLookupRequest enableTransliterationFlag(EnableTransliterationFlagEnum enableTransliterationFlag) {
    
    this.enableTransliterationFlag = enableTransliterationFlag;
    return this;
  }

   /**
   * Flag which indicates to/not to convert the Special Characters to ASCII for Sender &amp; Receiver details (Name, Address, Address in UAB). For Loyalty, this flag will be defaulted to Y. * If not passed in the request, as is values will be returned in response by default. * If passed as N in the request, as is values will be returned in response. * If passed as Y in the request, the Special Characters will be converted to ASCII and will be returned in response. 
   * @return enableTransliterationFlag
  **/
  @javax.annotation.Nullable
  public EnableTransliterationFlagEnum getEnableTransliterationFlag() {
    return enableTransliterationFlag;
  }


  public void setEnableTransliterationFlag(EnableTransliterationFlagEnum enableTransliterationFlag) {
    this.enableTransliterationFlag = enableTransliterationFlag;
  }


  public MultiParamNonKeyLookupRequest sendAllFundSrc(SendAllFundSrcEnum sendAllFundSrc) {
    
    this.sendAllFundSrc = sendAllFundSrc;
    return this;
  }

   /**
   * This flag would indicate to include all types of Funding Sources or not.    * If this flag value is N or not sent, then will return Funding Sources which are added by other than TMT.   * If the flag value is &#39;Y&#39;, then will return additional funding sources (like funding sources added by TMT), if any, along with funding sources added by other than TMT. 
   * @return sendAllFundSrc
  **/
  @javax.annotation.Nullable
  public SendAllFundSrcEnum getSendAllFundSrc() {
    return sendAllFundSrc;
  }


  public void setSendAllFundSrc(SendAllFundSrcEnum sendAllFundSrc) {
    this.sendAllFundSrc = sendAllFundSrc;
  }


  public MultiParamNonKeyLookupRequest sendAllPhoneVvStatus(SendAllPhoneVvStatusEnum sendAllPhoneVvStatus) {
    
    this.sendAllPhoneVvStatus = sendAllPhoneVvStatus;
    return this;
  }

   /**
   * This flag would indicate to include all the PhoneVvStatus or not.   * PhoneVvStatus - N / L / M / P will be returned in response by default.    * PhoneVvStatus - Z / T / R / S / V / A / B / U / C / D will only be returned if this field is send as Y in the request.&#39; 
   * @return sendAllPhoneVvStatus
  **/
  @javax.annotation.Nullable
  public SendAllPhoneVvStatusEnum getSendAllPhoneVvStatus() {
    return sendAllPhoneVvStatus;
  }


  public void setSendAllPhoneVvStatus(SendAllPhoneVvStatusEnum sendAllPhoneVvStatus) {
    this.sendAllPhoneVvStatus = sendAllPhoneVvStatus;
  }


  public MultiParamNonKeyLookupRequest noOfYearsInSearch(Integer noOfYearsInSearch) {
    
    this.noOfYearsInSearch = noOfYearsInSearch;
    return this;
  }

   /**
   * This flag would indicate to include the number of years in search. For Phoenix, this flag will be defaulted to last 2 years, where the start date will be the first day of the start date&#39;s year.    * If this field value is 0 or not available or field is not available, then it will search across all the years.   * If this field is &#39;X&#39; (greater than 0) then UCD will search for last &#39;X&#39; number of years from the current timestamp. 
   * @return noOfYearsInSearch
  **/
  @javax.annotation.Nullable
  public Integer getNoOfYearsInSearch() {
    return noOfYearsInSearch;
  }


  public void setNoOfYearsInSearch(Integer noOfYearsInSearch) {
    this.noOfYearsInSearch = noOfYearsInSearch;
  }


  public MultiParamNonKeyLookupRequest sendAllCustomerDetails(SendAllCustomerDetailsEnum sendAllCustomerDetails) {
    
    this.sendAllCustomerDetails = sendAllCustomerDetails;
    return this;
  }

   /**
   * This flag would indicate to include complete customer details or not (if a single match is found).   * If this flag value is N or not sent, then it will return limited details of the Customer.   * If the flag value is &#39;Y&#39;, then web service will return all the details of the Customer if a single match is found else will return limited details of the Customers. 
   * @return sendAllCustomerDetails
  **/
  @javax.annotation.Nullable
  public SendAllCustomerDetailsEnum getSendAllCustomerDetails() {
    return sendAllCustomerDetails;
  }


  public void setSendAllCustomerDetails(SendAllCustomerDetailsEnum sendAllCustomerDetails) {
    this.sendAllCustomerDetails = sendAllCustomerDetails;
  }


  @Deprecated
  public MultiParamNonKeyLookupRequest sendPrimaryProfileFlag(SendPrimaryProfileFlagEnum sendPrimaryProfileFlag) {
    
    this.sendPrimaryProfileFlag = sendPrimaryProfileFlag;
    return this;
  }

   /**
   * *Note: This field is deprecated. Please use enableCrossChannelFlag field instead.* * Flag which indicates to search across All profiles or only Primary UMN profile.   * If not passed in the request, all the profiles will be returned in response by default.   * If passed as N in the request, all the profiles will be returned in response.   * If passed as Y in the request, only the Primary UMN profile will be returned in response. 
   * @return sendPrimaryProfileFlag
   * @deprecated
  **/
  @Deprecated
  @javax.annotation.Nullable
  public SendPrimaryProfileFlagEnum getSendPrimaryProfileFlag() {
    return sendPrimaryProfileFlag;
  }


  @Deprecated
  public void setSendPrimaryProfileFlag(SendPrimaryProfileFlagEnum sendPrimaryProfileFlag) {
    this.sendPrimaryProfileFlag = sendPrimaryProfileFlag;
  }


  public MultiParamNonKeyLookupRequest enableCrossChannelFlag(EnableCrossChannelFlagEnum enableCrossChannelFlag) {
    
    this.enableCrossChannelFlag = enableCrossChannelFlag;
    return this;
  }

   /**
   * Flag which indicates to search across All profiles or only Primary UMN profile. * If not passed in the request, all the profiles will be returned in response by default. * If passed as N in the request, all the profiles will be returned in response. * If passed as Y in the request, then   * Only the Primary UMN profile will be returned in response.   * platform will get defaulted to A   * noOfYearsInSearch passed in the request will get ignored 
   * @return enableCrossChannelFlag
  **/
  @javax.annotation.Nullable
  public EnableCrossChannelFlagEnum getEnableCrossChannelFlag() {
    return enableCrossChannelFlag;
  }


  public void setEnableCrossChannelFlag(EnableCrossChannelFlagEnum enableCrossChannelFlag) {
    this.enableCrossChannelFlag = enableCrossChannelFlag;
  }


  public MultiParamNonKeyLookupRequest sendConsolidatedFundingSources(SendConsolidatedFundingSourcesEnum sendConsolidatedFundingSources) {
    
    this.sendConsolidatedFundingSources = sendConsolidatedFundingSources;
    return this;
  }

   /**
   * This flag would indicate to include consolidated funding sources from both primary &amp; secondary profiles or not.   * If this flag value is &#39;N&#39; or not sent, then it will return funding sources from primary profile only.   * If the flag value is &#39;Y&#39;, then web service will return consolidated funding sources from both primary &amp; scondary profiles. 
   * @return sendConsolidatedFundingSources
  **/
  @javax.annotation.Nullable
  public SendConsolidatedFundingSourcesEnum getSendConsolidatedFundingSources() {
    return sendConsolidatedFundingSources;
  }


  public void setSendConsolidatedFundingSources(SendConsolidatedFundingSourcesEnum sendConsolidatedFundingSources) {
    this.sendConsolidatedFundingSources = sendConsolidatedFundingSources;
  }


  public MultiParamNonKeyLookupRequest sendConsolidatedReceivers(SendConsolidatedReceiversEnum sendConsolidatedReceivers) {
    
    this.sendConsolidatedReceivers = sendConsolidatedReceivers;
    return this;
  }

   /**
   * This flag would indicate to include consolidated receviers from both primary &amp; secondary profiles or not.   * If this flag value is &#39;N&#39; or not sent, then it will return receviers from primary profile only.   * If the flag value is &#39;Y&#39;, then web service will return consolidated receivers from both primary &amp; scondary profiles. 
   * @return sendConsolidatedReceivers
  **/
  @javax.annotation.Nullable
  public SendConsolidatedReceiversEnum getSendConsolidatedReceivers() {
    return sendConsolidatedReceivers;
  }


  public void setSendConsolidatedReceivers(SendConsolidatedReceiversEnum sendConsolidatedReceivers) {
    this.sendConsolidatedReceivers = sendConsolidatedReceivers;
  }


  public MultiParamNonKeyLookupRequest phoneAndDobFlag(String phoneAndDobFlag) {
    
    this.phoneAndDobFlag = phoneAndDobFlag;
    return this;
  }

   /**
   * This flag would indicate to include variations for lookupType - PHD (Phone + Dob). If this flag is not passed in the request, then it will be defaulted to 4. This is a exact match with IsdCode + Phone Number / Phone Number. * 1 - Customer Profiles which matches with (Phone + DOB) &amp; (Phone + DOB (null)) will be returned in response. * 2 - Customer Profiles which matches with (Phone + DOB) will be returned in response. If no match(es) is/are found then, Customer Profiles which matches with Phone only will be returned in response. * 3 - Customer Profiles which matches with (Phone + DOB) will be returned in response. * 4 - Customer Profiles which matches with (Phone + DOB) will be returned in response. If no match(es) is/are found then, Customer Profiles which matches with (Phone + DOB (null)) only will be returned in response. 
   * @return phoneAndDobFlag
  **/
  @javax.annotation.Nullable
  public String getPhoneAndDobFlag() {
    return phoneAndDobFlag;
  }


  public void setPhoneAndDobFlag(String phoneAndDobFlag) {
    this.phoneAndDobFlag = phoneAndDobFlag;
  }


  public MultiParamNonKeyLookupRequest sortingOrder(String sortingOrder) {
    
    this.sortingOrder = sortingOrder;
    return this;
  }

   /**
   * This flag would to sort the Customer profiles in the response for lookupType - PHD (Phone + Dob). If this flag is not passed in the request, then it will be defaulted to 1. * 1 - Sort Customer Profiles based on Updated Date in descending order. * 2 - Sort Customer Profiles in the order of Digital -&gt; Retail -&gt; Conveninece -&gt; Partial + Updated Date in descending order. 
   * @return sortingOrder
  **/
  @javax.annotation.Nullable
  public String getSortingOrder() {
    return sortingOrder;
  }


  public void setSortingOrder(String sortingOrder) {
    this.sortingOrder = sortingOrder;
  }


  public MultiParamNonKeyLookupRequest sendCustHavingAccountFlag(List<Integer> sendCustHavingAccountFlag) {
    
    this.sendCustHavingAccountFlag = sendCustHavingAccountFlag;
    return this;
  }

  public MultiParamNonKeyLookupRequest addSendCustHavingAccountFlagItem(Integer sendCustHavingAccountFlagItem) {
    if (this.sendCustHavingAccountFlag == null) {
      this.sendCustHavingAccountFlag = new ArrayList<>();
    }
    this.sendCustHavingAccountFlag.add(sendCustHavingAccountFlagItem);
    return this;
  }

   /**
   * This flag would indicate to return only those customers having the account type id&#39;s passed in this field. 
   * @return sendCustHavingAccountFlag
  **/
  @javax.annotation.Nullable
  public List<Integer> getSendCustHavingAccountFlag() {
    return sendCustHavingAccountFlag;
  }


  public void setSendCustHavingAccountFlag(List<Integer> sendCustHavingAccountFlag) {
    this.sendCustHavingAccountFlag = sendCustHavingAccountFlag;
  }


  public MultiParamNonKeyLookupRequest countryCodeIso2(String countryCodeIso2) {
    
    this.countryCodeIso2 = countryCodeIso2;
    return this;
  }

   /**
   * Country code in ISO2 format. e.g. AT, IN, US etc. If countryCodeIso1 is passed and if the country is SCV enbaled, then   * enableCrossChannelFlag will get defaulted to Y   * platform will get defaulted to A\\   * noOfYearsInSearch passed in the request will get ignored 
   * @return countryCodeIso2
  **/
  @javax.annotation.Nullable
  public String getCountryCodeIso2() {
    return countryCodeIso2;
  }


  public void setCountryCodeIso2(String countryCodeIso2) {
    this.countryCodeIso2 = countryCodeIso2;
  }


  public MultiParamNonKeyLookupRequest countryCodeIso3(String countryCodeIso3) {
    
    this.countryCodeIso3 = countryCodeIso3;
    return this;
  }

   /**
   * Country code in ISO3 format. e.g. AUT, IND, USA etc. If countryCodeIso1 is passed and if the country is SCV enbaled, then   * enableCrossChannelFlag will get defaulted to Y   * platform will get defaulted to A\\   * noOfYearsInSearch passed in the request will get ignored 
   * @return countryCodeIso3
  **/
  @javax.annotation.Nullable
  public String getCountryCodeIso3() {
    return countryCodeIso3;
  }


  public void setCountryCodeIso3(String countryCodeIso3) {
    this.countryCodeIso3 = countryCodeIso3;
  }


  public MultiParamNonKeyLookupRequest requestInitiatedBy(String requestInitiatedBy) {
    
    this.requestInitiatedBy = requestInitiatedBy;
    return this;
  }

   /**
   * To identify who has initiated the request.
   * @return requestInitiatedBy
  **/
  @javax.annotation.Nonnull
  public String getRequestInitiatedBy() {
    return requestInitiatedBy;
  }


  public void setRequestInitiatedBy(String requestInitiatedBy) {
    this.requestInitiatedBy = requestInitiatedBy;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MultiParamNonKeyLookupRequest multiParamNonKeyLookupRequest = (MultiParamNonKeyLookupRequest) o;
    return Objects.equals(this.header, multiParamNonKeyLookupRequest.header) &&
        Objects.equals(this.lookupType, multiParamNonKeyLookupRequest.lookupType) &&
        Objects.equals(this.matchingType, multiParamNonKeyLookupRequest.matchingType) &&
        Objects.equals(this.lookupKey, multiParamNonKeyLookupRequest.lookupKey) &&
        Objects.equals(this.responseType, multiParamNonKeyLookupRequest.responseType) &&
        Objects.equals(this.startIndex, multiParamNonKeyLookupRequest.startIndex) &&
        Objects.equals(this.returnSize, multiParamNonKeyLookupRequest.returnSize) &&
        Objects.equals(this.customerActiveFlag, multiParamNonKeyLookupRequest.customerActiveFlag) &&
        Objects.equals(this.sendNonWuAlsoFlag, multiParamNonKeyLookupRequest.sendNonWuAlsoFlag) &&
        Objects.equals(this.sendPartialCustomerFlag, multiParamNonKeyLookupRequest.sendPartialCustomerFlag) &&
        Objects.equals(this.customerKycDetailsActiveFlag, multiParamNonKeyLookupRequest.customerKycDetailsActiveFlag) &&
        Objects.equals(this.checkOnlyForDigital, multiParamNonKeyLookupRequest.checkOnlyForDigital) &&
        Objects.equals(this.channelType, multiParamNonKeyLookupRequest.channelType) &&
        Objects.equals(this.includeConvenienceFlag, multiParamNonKeyLookupRequest.includeConvenienceFlag) &&
        Objects.equals(this.platform, multiParamNonKeyLookupRequest.platform) &&
        Objects.equals(this.sendAllPfc, multiParamNonKeyLookupRequest.sendAllPfc) &&
        Objects.equals(this.enableTransliterationFlag, multiParamNonKeyLookupRequest.enableTransliterationFlag) &&
        Objects.equals(this.sendAllFundSrc, multiParamNonKeyLookupRequest.sendAllFundSrc) &&
        Objects.equals(this.sendAllPhoneVvStatus, multiParamNonKeyLookupRequest.sendAllPhoneVvStatus) &&
        Objects.equals(this.noOfYearsInSearch, multiParamNonKeyLookupRequest.noOfYearsInSearch) &&
        Objects.equals(this.sendAllCustomerDetails, multiParamNonKeyLookupRequest.sendAllCustomerDetails) &&
        Objects.equals(this.sendPrimaryProfileFlag, multiParamNonKeyLookupRequest.sendPrimaryProfileFlag) &&
        Objects.equals(this.enableCrossChannelFlag, multiParamNonKeyLookupRequest.enableCrossChannelFlag) &&
        Objects.equals(this.sendConsolidatedFundingSources, multiParamNonKeyLookupRequest.sendConsolidatedFundingSources) &&
        Objects.equals(this.sendConsolidatedReceivers, multiParamNonKeyLookupRequest.sendConsolidatedReceivers) &&
        Objects.equals(this.phoneAndDobFlag, multiParamNonKeyLookupRequest.phoneAndDobFlag) &&
        Objects.equals(this.sortingOrder, multiParamNonKeyLookupRequest.sortingOrder) &&
        Objects.equals(this.sendCustHavingAccountFlag, multiParamNonKeyLookupRequest.sendCustHavingAccountFlag) &&
        Objects.equals(this.countryCodeIso2, multiParamNonKeyLookupRequest.countryCodeIso2) &&
        Objects.equals(this.countryCodeIso3, multiParamNonKeyLookupRequest.countryCodeIso3) &&
        Objects.equals(this.requestInitiatedBy, multiParamNonKeyLookupRequest.requestInitiatedBy);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(header, lookupType, matchingType, lookupKey, responseType, startIndex, returnSize, customerActiveFlag, sendNonWuAlsoFlag, sendPartialCustomerFlag, customerKycDetailsActiveFlag, checkOnlyForDigital, channelType, includeConvenienceFlag, platform, sendAllPfc, enableTransliterationFlag, sendAllFundSrc, sendAllPhoneVvStatus, noOfYearsInSearch, sendAllCustomerDetails, sendPrimaryProfileFlag, enableCrossChannelFlag, sendConsolidatedFundingSources, sendConsolidatedReceivers, phoneAndDobFlag, sortingOrder, sendCustHavingAccountFlag, countryCodeIso2, countryCodeIso3, requestInitiatedBy);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class MultiParamNonKeyLookupRequest {\n");
    sb.append("    header: ").append(toIndentedString(header)).append("\n");
    sb.append("    lookupType: ").append(toIndentedString(lookupType)).append("\n");
    sb.append("    matchingType: ").append(toIndentedString(matchingType)).append("\n");
    sb.append("    lookupKey: ").append(toIndentedString(lookupKey)).append("\n");
    sb.append("    responseType: ").append(toIndentedString(responseType)).append("\n");
    sb.append("    startIndex: ").append(toIndentedString(startIndex)).append("\n");
    sb.append("    returnSize: ").append(toIndentedString(returnSize)).append("\n");
    sb.append("    customerActiveFlag: ").append(toIndentedString(customerActiveFlag)).append("\n");
    sb.append("    sendNonWuAlsoFlag: ").append(toIndentedString(sendNonWuAlsoFlag)).append("\n");
    sb.append("    sendPartialCustomerFlag: ").append(toIndentedString(sendPartialCustomerFlag)).append("\n");
    sb.append("    customerKycDetailsActiveFlag: ").append(toIndentedString(customerKycDetailsActiveFlag)).append("\n");
    sb.append("    checkOnlyForDigital: ").append(toIndentedString(checkOnlyForDigital)).append("\n");
    sb.append("    channelType: ").append(toIndentedString(channelType)).append("\n");
    sb.append("    includeConvenienceFlag: ").append(toIndentedString(includeConvenienceFlag)).append("\n");
    sb.append("    platform: ").append(toIndentedString(platform)).append("\n");
    sb.append("    sendAllPfc: ").append(toIndentedString(sendAllPfc)).append("\n");
    sb.append("    enableTransliterationFlag: ").append(toIndentedString(enableTransliterationFlag)).append("\n");
    sb.append("    sendAllFundSrc: ").append(toIndentedString(sendAllFundSrc)).append("\n");
    sb.append("    sendAllPhoneVvStatus: ").append(toIndentedString(sendAllPhoneVvStatus)).append("\n");
    sb.append("    noOfYearsInSearch: ").append(toIndentedString(noOfYearsInSearch)).append("\n");
    sb.append("    sendAllCustomerDetails: ").append(toIndentedString(sendAllCustomerDetails)).append("\n");
    sb.append("    sendPrimaryProfileFlag: ").append(toIndentedString(sendPrimaryProfileFlag)).append("\n");
    sb.append("    enableCrossChannelFlag: ").append(toIndentedString(enableCrossChannelFlag)).append("\n");
    sb.append("    sendConsolidatedFundingSources: ").append(toIndentedString(sendConsolidatedFundingSources)).append("\n");
    sb.append("    sendConsolidatedReceivers: ").append(toIndentedString(sendConsolidatedReceivers)).append("\n");
    sb.append("    phoneAndDobFlag: ").append(toIndentedString(phoneAndDobFlag)).append("\n");
    sb.append("    sortingOrder: ").append(toIndentedString(sortingOrder)).append("\n");
    sb.append("    sendCustHavingAccountFlag: ").append(toIndentedString(sendCustHavingAccountFlag)).append("\n");
    sb.append("    countryCodeIso2: ").append(toIndentedString(countryCodeIso2)).append("\n");
    sb.append("    countryCodeIso3: ").append(toIndentedString(countryCodeIso3)).append("\n");
    sb.append("    requestInitiatedBy: ").append(toIndentedString(requestInitiatedBy)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("header");
    openapiFields.add("lookupType");
    openapiFields.add("matchingType");
    openapiFields.add("lookupKey");
    openapiFields.add("responseType");
    openapiFields.add("startIndex");
    openapiFields.add("returnSize");
    openapiFields.add("customerActiveFlag");
    openapiFields.add("sendNonWuAlsoFlag");
    openapiFields.add("sendPartialCustomerFlag");
    openapiFields.add("customerKycDetailsActiveFlag");
    openapiFields.add("checkOnlyForDigital");
    openapiFields.add("channelType");
    openapiFields.add("includeConvenienceFlag");
    openapiFields.add("platform");
    openapiFields.add("sendAllPfc");
    openapiFields.add("enableTransliterationFlag");
    openapiFields.add("sendAllFundSrc");
    openapiFields.add("sendAllPhoneVvStatus");
    openapiFields.add("noOfYearsInSearch");
    openapiFields.add("sendAllCustomerDetails");
    openapiFields.add("sendPrimaryProfileFlag");
    openapiFields.add("enableCrossChannelFlag");
    openapiFields.add("sendConsolidatedFundingSources");
    openapiFields.add("sendConsolidatedReceivers");
    openapiFields.add("phoneAndDobFlag");
    openapiFields.add("sortingOrder");
    openapiFields.add("sendCustHavingAccountFlag");
    openapiFields.add("countryCodeIso2");
    openapiFields.add("countryCodeIso3");
    openapiFields.add("requestInitiatedBy");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("header");
    openapiRequiredFields.add("lookupType");
    openapiRequiredFields.add("matchingType");
    openapiRequiredFields.add("lookupKey");
    openapiRequiredFields.add("responseType");
    openapiRequiredFields.add("startIndex");
    openapiRequiredFields.add("returnSize");
    openapiRequiredFields.add("customerActiveFlag");
    openapiRequiredFields.add("requestInitiatedBy");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to MultiParamNonKeyLookupRequest
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!MultiParamNonKeyLookupRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in MultiParamNonKeyLookupRequest is not found in the empty JSON string", MultiParamNonKeyLookupRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!MultiParamNonKeyLookupRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `MultiParamNonKeyLookupRequest` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : MultiParamNonKeyLookupRequest.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      // validate the required field `header`
      Header.validateJsonObject(jsonObj.getAsJsonObject("header"));
      if (!jsonObj.get("lookupType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lookupType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lookupType").toString()));
      }
      if (!jsonObj.get("matchingType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `matchingType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("matchingType").toString()));
      }
      // validate the required field `lookupKey`
      MultiParamLookupKey.validateJsonObject(jsonObj.getAsJsonObject("lookupKey"));
      if (!jsonObj.get("responseType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `responseType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("responseType").toString()));
      }
      if (!jsonObj.get("customerActiveFlag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `customerActiveFlag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("customerActiveFlag").toString()));
      }
      if ((jsonObj.get("sendNonWuAlsoFlag") != null && !jsonObj.get("sendNonWuAlsoFlag").isJsonNull()) && !jsonObj.get("sendNonWuAlsoFlag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sendNonWuAlsoFlag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sendNonWuAlsoFlag").toString()));
      }
      if ((jsonObj.get("sendPartialCustomerFlag") != null && !jsonObj.get("sendPartialCustomerFlag").isJsonNull()) && !jsonObj.get("sendPartialCustomerFlag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sendPartialCustomerFlag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sendPartialCustomerFlag").toString()));
      }
      if ((jsonObj.get("customerKycDetailsActiveFlag") != null && !jsonObj.get("customerKycDetailsActiveFlag").isJsonNull()) && !jsonObj.get("customerKycDetailsActiveFlag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `customerKycDetailsActiveFlag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("customerKycDetailsActiveFlag").toString()));
      }
      if ((jsonObj.get("checkOnlyForDigital") != null && !jsonObj.get("checkOnlyForDigital").isJsonNull()) && !jsonObj.get("checkOnlyForDigital").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `checkOnlyForDigital` to be a primitive type in the JSON string but got `%s`", jsonObj.get("checkOnlyForDigital").toString()));
      }
      if ((jsonObj.get("includeConvenienceFlag") != null && !jsonObj.get("includeConvenienceFlag").isJsonNull()) && !jsonObj.get("includeConvenienceFlag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `includeConvenienceFlag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("includeConvenienceFlag").toString()));
      }
      if ((jsonObj.get("platform") != null && !jsonObj.get("platform").isJsonNull()) && !jsonObj.get("platform").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `platform` to be a primitive type in the JSON string but got `%s`", jsonObj.get("platform").toString()));
      }
      if ((jsonObj.get("sendAllPfc") != null && !jsonObj.get("sendAllPfc").isJsonNull()) && !jsonObj.get("sendAllPfc").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sendAllPfc` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sendAllPfc").toString()));
      }
      if ((jsonObj.get("enableTransliterationFlag") != null && !jsonObj.get("enableTransliterationFlag").isJsonNull()) && !jsonObj.get("enableTransliterationFlag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `enableTransliterationFlag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("enableTransliterationFlag").toString()));
      }
      if ((jsonObj.get("sendAllFundSrc") != null && !jsonObj.get("sendAllFundSrc").isJsonNull()) && !jsonObj.get("sendAllFundSrc").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sendAllFundSrc` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sendAllFundSrc").toString()));
      }
      if ((jsonObj.get("sendAllPhoneVvStatus") != null && !jsonObj.get("sendAllPhoneVvStatus").isJsonNull()) && !jsonObj.get("sendAllPhoneVvStatus").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sendAllPhoneVvStatus` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sendAllPhoneVvStatus").toString()));
      }
      if ((jsonObj.get("sendAllCustomerDetails") != null && !jsonObj.get("sendAllCustomerDetails").isJsonNull()) && !jsonObj.get("sendAllCustomerDetails").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sendAllCustomerDetails` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sendAllCustomerDetails").toString()));
      }
      if ((jsonObj.get("sendPrimaryProfileFlag") != null && !jsonObj.get("sendPrimaryProfileFlag").isJsonNull()) && !jsonObj.get("sendPrimaryProfileFlag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sendPrimaryProfileFlag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sendPrimaryProfileFlag").toString()));
      }
      if ((jsonObj.get("enableCrossChannelFlag") != null && !jsonObj.get("enableCrossChannelFlag").isJsonNull()) && !jsonObj.get("enableCrossChannelFlag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `enableCrossChannelFlag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("enableCrossChannelFlag").toString()));
      }
      if ((jsonObj.get("sendConsolidatedFundingSources") != null && !jsonObj.get("sendConsolidatedFundingSources").isJsonNull()) && !jsonObj.get("sendConsolidatedFundingSources").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sendConsolidatedFundingSources` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sendConsolidatedFundingSources").toString()));
      }
      if ((jsonObj.get("sendConsolidatedReceivers") != null && !jsonObj.get("sendConsolidatedReceivers").isJsonNull()) && !jsonObj.get("sendConsolidatedReceivers").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sendConsolidatedReceivers` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sendConsolidatedReceivers").toString()));
      }
      if ((jsonObj.get("phoneAndDobFlag") != null && !jsonObj.get("phoneAndDobFlag").isJsonNull()) && !jsonObj.get("phoneAndDobFlag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `phoneAndDobFlag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("phoneAndDobFlag").toString()));
      }
      if ((jsonObj.get("sortingOrder") != null && !jsonObj.get("sortingOrder").isJsonNull()) && !jsonObj.get("sortingOrder").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sortingOrder` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sortingOrder").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("sendCustHavingAccountFlag") != null && !jsonObj.get("sendCustHavingAccountFlag").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `sendCustHavingAccountFlag` to be an array in the JSON string but got `%s`", jsonObj.get("sendCustHavingAccountFlag").toString()));
      }
      if ((jsonObj.get("countryCodeIso2") != null && !jsonObj.get("countryCodeIso2").isJsonNull()) && !jsonObj.get("countryCodeIso2").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `countryCodeIso2` to be a primitive type in the JSON string but got `%s`", jsonObj.get("countryCodeIso2").toString()));
      }
      if ((jsonObj.get("countryCodeIso3") != null && !jsonObj.get("countryCodeIso3").isJsonNull()) && !jsonObj.get("countryCodeIso3").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `countryCodeIso3` to be a primitive type in the JSON string but got `%s`", jsonObj.get("countryCodeIso3").toString()));
      }
      if (!jsonObj.get("requestInitiatedBy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `requestInitiatedBy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("requestInitiatedBy").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!MultiParamNonKeyLookupRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'MultiParamNonKeyLookupRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<MultiParamNonKeyLookupRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(MultiParamNonKeyLookupRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<MultiParamNonKeyLookupRequest>() {
           @Override
           public void write(JsonWriter out, MultiParamNonKeyLookupRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public MultiParamNonKeyLookupRequest read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of MultiParamNonKeyLookupRequest given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of MultiParamNonKeyLookupRequest
  * @throws IOException if the JSON string is invalid with respect to MultiParamNonKeyLookupRequest
  */
  public static MultiParamNonKeyLookupRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, MultiParamNonKeyLookupRequest.class);
  }

 /**
  * Convert an instance of MultiParamNonKeyLookupRequest to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

